<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caffeine Procurement | The Office Games</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Global Box Sizing */
        * { box-sizing: border-box; }

        :root {
            --bg-color: #f8fafc;
            --panel-bg: #ffffff;
            --text-primary: #0f172a;
            --text-secondary: #64748b;
            --accent-blue: #2563eb;
            --accent-red: #ef4444;
            --accent-orange: #f97316;
            
            --floor-color: #ffffff;
            --grid-color: #e2e8f0;
            --wall-color: #334155;
            --vision-color: rgba(239, 68, 68, 0.2); /* Red tint for vision */
            --vision-frozen: rgba(59, 130, 246, 0.2); /* Blue tint when frozen */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; 
        }

        /* Header Layout: Fixed at top (Same as Chess) */
        header {
            width: 100%;
            background: transparent; 
            backdrop-filter: blur(2px); 
            border-bottom: none;
            padding: 1.5rem 2rem; 
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            box-shadow: none;
            position: fixed; 
            top: 0;
            left: 0;
            z-index: 50;
        }

        .header-left { justify-self: start; }
        .header-center { display: flex; flex-direction: column; align-items: center; }
        .header-right { justify-self: end; }

        .brand { 
            font-weight: 800; 
            font-size: 1.1rem; 
            letter-spacing: -0.025em;
            color: var(--text-primary);
            text-align: center;
        }
        
        .employee-badge { 
            font-size: 0.75rem; 
            color: var(--text-secondary); 
            margin-top: 2px;
            font-weight: 500;
        }

        /* Minimal Buttons */
        .nav-btn {
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid #cbd5e1;
            padding: 8px 16px; 
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        .nav-btn:hover {
            background: rgba(255,255,255,1);
            color: var(--text-primary);
            border-color: #94a3b8;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Game Container */
        .game-wrapper {
            flex: 1;
            margin-top: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 0 1rem;
        }

        /* Stats Card */
        .level-card {
            background: white;
            padding: 0.75rem 2rem;
            border-radius: 50px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            border: 1px solid #e2e8f0;
            font-size: 0.9rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .level-info { font-weight: 700; color: var(--text-primary); }
        .score-info { color: var(--text-secondary); border-left: 1px solid #cbd5e1; padding-left: 1.5rem; }

        /* Canvas Style - Floor Plan Look */
        #gameCanvas {
            background-color: var(--floor-color);
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            max-width: 100%;
            max-height: 60vh;
            touch-action: none;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none; 
            margin-top: 20px;
            gap: 10px;
        }

        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 50px);
            grid-template-rows: repeat(2, 50px);
            gap: 8px;
        }

        .ctrl-btn {
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .ctrl-btn:active { background: #f1f5f9; transform: scale(0.95); }

        /* Feedback Modal/Toaster */
        #feedback {
            position: fixed;
            top: 100px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.95rem;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            text-align: left;
            min-width: 280px;
            z-index: 100;
            background: white;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            transform: translateX(40px);
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid #e2e8f0;
        }

        #feedback.show { opacity: 1; transform: translateX(0); }

        #feedback span {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 14px;
        }

        .success { 
            background-color: #f0fdf4 !important;
            border-color: #bbf7d0 !important;
            color: #166534; 
        }
        .success span {
            background-color: #dcfce7;
            color: #166534;
        }

        .error { 
            background-color: #fef2f2 !important;
            border-color: #fecaca !important;
            color: #991b1b; 
        }
        .error span {
            background-color: #fee2e2;
            color: #991b1b;
        }

        footer {
            margin-top: auto;
            padding: 1.5rem;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            width: 100%;
        }

        @media (max-width: 768px) {
            .mobile-controls { display: flex; }
            .header-center { display: none; }
            #feedback { 
                top: auto; 
                bottom: 20px; 
                right: 20px; 
                left: 20px; 
                text-align: center;
                justify-content: center;
                transform: translateY(40px);
            }
            #feedback.show { transform: translateY(0); }
        }
    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <button class="nav-btn" onclick="goHome()">Home</button>
        </div>
        <div class="header-center">
            <div class="brand">CAFFEINE PROCUREMENT</div>
            <div class="employee-badge" id="emp-id">Authenticating...</div>
        </div>
        <div class="header-right">
            <button class="nav-btn" onclick="resetGame()">Restart</button>
        </div>
    </header>

    <div class="game-wrapper">
        <div class="level-card">
            <div class="level-info">Floor <span id="level-display">1</span></div>
            <div class="score-info">Record: <span id="record-display">1</span></div>
            <div class="score-info">Energy: <span id="score-display">0</span>%</div>
            <div class="score-info" id="freeze-status" style="display:none; color: var(--accent-blue);">‚ùÑÔ∏è Frozen</div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>

        <div class="mobile-controls">
            <div class="d-pad">
                <div style="grid-column: 2;" class="ctrl-btn" ontouchstart="handleInput('ArrowUp')" onmousedown="handleInput('ArrowUp')">‚ñ≤</div>
                <div style="grid-row: 2; grid-column: 1;" class="ctrl-btn" ontouchstart="handleInput('ArrowLeft')" onmousedown="handleInput('ArrowLeft')">‚óÄ</div>
                <div style="grid-row: 2; grid-column: 2;" class="ctrl-btn" ontouchstart="handleInput('ArrowDown')" onmousedown="handleInput('ArrowDown')">‚ñº</div>
                <div style="grid-row: 2; grid-column: 3;" class="ctrl-btn" ontouchstart="handleInput('ArrowRight')" onmousedown="handleInput('ArrowRight')">‚ñ∂</div>
            </div>
        </div>
    </div>

    <div id="feedback"></div>

    <footer>
        &copy; <span id="year"></span> Gravity | Created By Pritish & GenAI
    </footer>

    <script>
        // --- Constants ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 40;
        const ROWS = 10;
        const COLS = 10;

        // --- State ---
        let level = 1;
        let score = 0;
        let maxLevel = 1; // Highest Floor Reached
        let isGameOver = false;
        let isPaused = false;
        let freezeTimer = 0; // Number of enemy ticks frozen
        let feedbackTimeout;
        let enemyInterval = null; // Timer for enemy movement

        // Entities
        let player = { x: 1, y: 1 };
        let goal = { x: 8, y: 8 };
        let enemies = [];
        let donuts = [];
        let walls = [];

        // Maps (1 = Wall)
        const maps = [
            // 1: Lobby
            [
                [1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,1],
                [1,1,1,1,0,0,1,0,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,1,0,1],
                [1,1,1,0,1,1,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ],
            // 2: Cubicles
            [
                [1,1,1,1,1,1,1,1,1,1],
                [1,0,0,1,0,0,0,0,0,1],
                [1,0,0,1,0,1,1,1,0,1],
                [1,0,0,0,0,1,0,0,0,1],
                [1,1,1,1,0,1,0,1,1,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,1,0,1],
                [1,0,1,0,0,0,1,0,0,1],
                [1,0,0,0,1,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ],
            // 3: Exec Suite
            [
                [1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,0,1,0,1,0,1,0,0,1],
                [1,0,1,0,1,0,1,0,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,1,0,1,1,1,1,0,1,1],
                [1,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ]
        ];

        // --- Init ---
        function init() {
            document.getElementById('year').textContent = new Date().getFullYear();
            const empId = localStorage.getItem('gravity_employee_id') || 'Visitor';
            document.getElementById('emp-id').textContent = empId;

            // Load Record
            const storedMax = localStorage.getItem('gravity_coffee_max_floor');
            maxLevel = storedMax ? parseInt(storedMax, 10) : 1;

            window.addEventListener('keydown', (e) => {
                if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                    e.preventDefault();
                    handleInput(e.code);
                }
            });

            startLevel();
            requestAnimationFrame(renderLoop);
        }

        function startLevel() {
            isGameOver = false;
            isPaused = false;
            freezeTimer = 0;
            
            // Clear any existing enemy timer
            if(enemyInterval) clearInterval(enemyInterval);

            // Map Setup
            const mapIndex = (level - 1) % maps.length;
            const currentMap = maps[mapIndex];
            walls = [];
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    if(currentMap[r][c] === 1) walls.push({x:c, y:r});
                }
            }

            // Player & Goal
            player = { x: 1, y: 1 };
            goal = { x: COLS-2, y: ROWS-2 };
            if(isWall(goal.x, goal.y)) goal = { x: COLS-3, y: ROWS-2 };

            // Enemies (Managers)
            enemies = [];
            const enemyCount = 2 + Math.floor(level / 1.5);
            for(let i=0; i<enemyCount; i++) {
                spawnEntity(enemies, 'enemy');
            }

            // Donuts (Powerups)
            donuts = [];
            spawnEntity(donuts, 'donut');

            updateUI();
            
            // Start Enemy Movement Loop (Real-time movement)
            // Enemies move every 500ms
            enemyInterval = setInterval(gameTick, 500);

            // Initial render
            render();
        }

        function spawnEntity(list, type) {
            let ex, ey;
            do {
                ex = Math.floor(Math.random() * COLS);
                ey = Math.floor(Math.random() * ROWS);
            } while(isWall(ex, ey) || (ex < 4 && ey < 4) || (ex === goal.x && ey === goal.y));
            
            if(type === 'enemy') {
                list.push({
                    x: ex, y: ey,
                    dirX: Math.random() > 0.5 ? 1 : 0,
                    dirY: 0,
                    visionRange: 2
                });
                if(list[list.length-1].dirX === 0) list[list.length-1].dirY = 1;
            } else {
                list.push({x: ex, y: ey});
            }
        }

        // --- Logic ---

        function handleInput(key) {
            if (isGameOver || isPaused) return;

            let dx = 0, dy = 0;
            if (key === 'ArrowUp') dy = -1;
            if (key === 'ArrowDown') dy = 1;
            if (key === 'ArrowLeft') dx = -1;
            if (key === 'ArrowRight') dx = 1;

            const newX = player.x + dx;
            const newY = player.y + dy;

            if (!isWall(newX, newY)) {
                player.x = newX;
                player.y = newY;
                // Note: We removed gameTick() here. Player moves freely.
                // We still check collisions immediately after moving.
                checkItemCollection();
                checkCollisions();
                checkWin();
            }
        }

        function gameTick() {
            if (isGameOver || isPaused) return;

            // Move Enemies
            if (freezeTimer > 0) {
                freezeTimer--;
            } else {
                enemies.forEach(enemy => {
                    let nextX = enemy.x + enemy.dirX;
                    let nextY = enemy.y + enemy.dirY;

                    if (isWall(nextX, nextY) || Math.random() < 0.1) {
                        const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                        const validDirs = dirs.filter(d => !isWall(enemy.x + d.x, enemy.y + d.y));
                        if(validDirs.length > 0) {
                            const newDir = validDirs[Math.floor(Math.random() * validDirs.length)];
                            enemy.dirX = newDir.x;
                            enemy.dirY = newDir.y;
                        } else {
                            enemy.dirX *= -1; enemy.dirY *= -1;
                        }
                    } else {
                        enemy.x = nextX;
                        enemy.y = nextY;
                    }
                });
            }

            checkCollisions();
            updateUI();
        }

        function checkItemCollection() {
             const donutIdx = donuts.findIndex(d => d.x === player.x && d.y === player.y);
            if (donutIdx > -1) {
                donuts.splice(donutIdx, 1);
                score += 50;
                freezeTimer += 10; // Freeze for 10 ticks (5 seconds)
                showFeedback(true, "HR Violation: Free Donuts! Managers Frozen.");
                updateUI();
            }
        }

        function checkCollisions() {
            // Direct collision
            if (enemies.some(e => e.x === player.x && e.y === player.y)) {
                gameOver("Micro-management encounter!");
                return;
            }

            // Vision Cone
            if (freezeTimer === 0) {
                for (let e of enemies) {
                    for (let i = 1; i <= e.visionRange; i++) {
                        const vx = e.x + (e.dirX * i);
                        const vy = e.y + (e.dirY * i);
                        if (isWall(vx, vy)) break; 
                        
                        if (vx === player.x && vy === player.y) {
                            gameOver("Spotted by Manager!");
                            return;
                        }
                    }
                }
            }
        }

        function checkWin() {
            if (player.x === goal.x && player.y === goal.y) {
                score += 100;
                level++;
                
                // Update Max Floor Reached
                if (level > maxLevel) {
                    maxLevel = level;
                    localStorage.setItem('gravity_coffee_max_floor', maxLevel);
                }
                
                showFeedback(true, "Caffeine Secured. Proceeding to next floor.");
                isPaused = true;
                if(enemyInterval) clearInterval(enemyInterval);
                
                setTimeout(() => {
                    startLevel();
                }, 1500);
            }
        }

        function gameOver(reason) {
            isGameOver = true;
            if(enemyInterval) clearInterval(enemyInterval);
            showFeedback(false, reason);
        }

        function resetGame() {
            level = 1;
            score = 0;
            startLevel();
            showFeedback(true, "Simulation Reset.");
        }

        function isWall(x, y) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return true;
            return walls.some(w => w.x === x && w.y === y);
        }

        // --- Rendering ---
        function renderLoop() {
            render();
            requestAnimationFrame(renderLoop);
        }

        function render() {
            // 1. Background (Clean White/Gray)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Grid Lines (Blueprint style)
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            for(let i=0; i<=COLS; i++) {
                ctx.beginPath(); ctx.moveTo(i*TILE_SIZE, 0); ctx.lineTo(i*TILE_SIZE, canvas.height); ctx.stroke();
            }
            for(let i=0; i<=ROWS; i++) {
                ctx.beginPath(); ctx.moveTo(0, i*TILE_SIZE); ctx.lineTo(canvas.width, i*TILE_SIZE); ctx.stroke();
            }

            // 3. Vision Cones (Soft Red or Blue)
            const visionColor = freezeTimer > 0 ? 'rgba(59, 130, 246, 0.2)' : 'rgba(239, 68, 68, 0.2)';
            ctx.fillStyle = visionColor;
            
            enemies.forEach(e => {
                for (let i = 1; i <= e.visionRange; i++) {
                    const vx = e.x + (e.dirX * i);
                    const vy = e.y + (e.dirY * i);
                    if (isWall(vx, vy)) break;
                    // Draw soft rect
                    ctx.fillRect(vx * TILE_SIZE + 2, vy * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                }
            });

            // 4. Walls (Cubicles)
            ctx.fillStyle = '#334155'; // Dark Slate
            walls.forEach(w => {
                // Main Block
                ctx.fillRect(w.x * TILE_SIZE + 2, w.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                // Top Highlight for depth
                ctx.fillStyle = '#475569';
                ctx.fillRect(w.x * TILE_SIZE + 2, w.y * TILE_SIZE + 2, TILE_SIZE - 4, 6);
                ctx.fillStyle = '#334155'; // Reset
            });

            // 5. Goal (Coffee)
            ctx.font = '28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚òï', (goal.x + 0.5) * TILE_SIZE, (goal.y + 0.5) * TILE_SIZE);

            // 6. Donuts
            donuts.forEach(d => {
                ctx.fillText('üç©', (d.x + 0.5) * TILE_SIZE, (d.y + 0.5) * TILE_SIZE);
            });

            // 7. Enemies (Managers)
            enemies.forEach(e => {
                // Circle
                ctx.fillStyle = freezeTimer > 0 ? '#60a5fa' : '#ef4444'; // Blue if frozen, Red normal
                const cx = (e.x + 0.5) * TILE_SIZE;
                const cy = (e.y + 0.5) * TILE_SIZE;
                
                ctx.beginPath();
                ctx.arc(cx, cy, TILE_SIZE/3, 0, Math.PI*2);
                ctx.fill();

                // Direction Indicator (Triangle)
                ctx.save();
                ctx.translate(cx, cy);
                let angle = 0;
                if(e.dirX === 1) angle = 0;
                if(e.dirX === -1) angle = Math.PI;
                if(e.dirY === 1) angle = Math.PI/2;
                if(e.dirY === -1) angle = -Math.PI/2;
                ctx.rotate(angle);
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(-4, 4);
                ctx.lineTo(-4, -4);
                ctx.fill();
                ctx.restore();
            });

            // 8. Player
            ctx.fillStyle = '#2563eb'; // Corporate Blue
            ctx.beginPath();
            ctx.arc((player.x + 0.5) * TILE_SIZE, (player.y + 0.5) * TILE_SIZE, TILE_SIZE/3, 0, Math.PI*2);
            ctx.fill();
            
            // Player Initials
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px Inter';
            ctx.fillText('ME', (player.x + 0.5) * TILE_SIZE, (player.y + 0.5) * TILE_SIZE);
        }

        // --- UI Utils ---
        function updateUI() {
            document.getElementById('level-display').textContent = level;
            document.getElementById('score-display').textContent = score;
            document.getElementById('record-display').textContent = maxLevel;
            const freezeStatus = document.getElementById('freeze-status');
            
            if (freezeTimer > 0) {
                freezeStatus.style.display = 'block';
                freezeStatus.textContent = `‚ùÑÔ∏è Frozen (${freezeTimer})`;
            } else {
                freezeStatus.style.display = 'none';
            }
        }

        function showFeedback(isSuccess, msg) {
            const fb = document.getElementById('feedback');
            fb.innerHTML = isSuccess ? '<span>‚úì</span> ' + msg : '<span>‚úï</span> ' + msg;
            fb.className = isSuccess ? 'success show' : 'error show';
            
            if (feedbackTimeout) clearTimeout(feedbackTimeout);
            
            // If success (level complete), keep it longer/until next level loads
            const duration = isSuccess ? 2000 : 3000;
            
            feedbackTimeout = setTimeout(() => {
                fb.classList.remove('show');
            }, duration);
        }

        function goHome() {
            window.location.href = '/index.html';
        }

        init();

    </script>
</body>
</html>